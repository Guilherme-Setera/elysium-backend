name: Deploy Elysium Backend (VPS)

on:
  push:
    branches: ["main"]
    paths:
      - "Dockerfile"
      - "docker-compose.yml"
      - "src/**"
      - "requirements.txt"
      - "main.py"
      - ".github/workflows/deploy.yml"
  workflow_dispatch:

concurrency:
  group: deploy-elysium-vps
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Write SSH key
        shell: bash
        run: |
          umask 077
          (echo "${{ secrets.VPS_SSH_KEY }}" | base64 -d > ./hostinger_ci) 2>/dev/null || printf '%s' "${{ secrets.VPS_SSH_KEY }}" > ./hostinger_ci
          chmod 600 ./hostinger_ci

      - name: Prepare known_hosts and test SSH
        shell: bash
        run: |
          install -m 700 -d ~/.ssh
          PORT="${{ secrets.VPS_PORT }}"; [ -z "$PORT" ] && PORT=22
          ssh-keyscan -p "$PORT" -H "${{ secrets.VPS_HOST }}" >> ~/.ssh/known_hosts
          ssh -i ./hostinger_ci -p "$PORT" -o StrictHostKeyChecking=yes "${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}" "echo connected"

      - name: SSH into VPS and deploy
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          port: ${{ secrets.VPS_PORT }}
          key_path: ./hostinger_ci
          debug: true
          script_stop: true
          script: |
            set -euo pipefail

            WORKDIR="${HOME}/elysium-backend"
            mkdir -p "$WORKDIR"
            cd "$WORKDIR"

            # Sincroniza repo (sempre "hard reset" para evitar sobras locais)
            if [ ! -d .git ]; then
              git init -q
              git remote add origin "https://github.com/${{ github.repository }}"
            fi
            git fetch --prune --depth=1 origin main
            git checkout -B main origin/main
            git reset --hard origin/main
            git clean -fdx

            # .env mínimo e limpo
            cat > .env << 'EOF'
            ENVIRONMENT=${{ secrets.ENVIRONMENT }}
            PORT=${{ secrets.PORT }}
            WEB_CONCURRENCY=${{ secrets.WEB_CONCURRENCY }}
            ORIGINS=${{ secrets.ORIGINS }}

            POSTGRES_SERVER=db
            POSTGRES_PORT=5432
            POSTGRES_DATABASE=${{ secrets.POSTGRES_DATABASE }}
            POSTGRES_USERNAME=${{ secrets.POSTGRES_USERNAME }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            POSTGRES_SSLMODE=${{ secrets.POSTGRES_SSLMODE }}

            JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
            JWT_REFRESH_SECRET_KEY=${{ secrets.JWT_REFRESH_SECRET_KEY }}
            JWT_REFRESH_TOKEN_EXPIRE_DAYS=${{ secrets.JWT_REFRESH_TOKEN_EXPIRE_DAYS }}
            EOF

            # Nunca criar .env.db (para não ser acidentalmente consumido)
            rm -f .env.db docker-compose.override.yml || true

            echo "[1/6] docker compose build (sem cache)"
            docker compose build --pull --no-cache

            echo "[2/6] sobe containers"
            docker compose up -d --force-recreate --remove-orphans

            echo "[3/6] estado:"
            docker compose ps

            echo "[4/6] Esperar Postgres responder (pg_isready dentro do container)"
            ATTEMPTS=60
            SLEEP=2
            i=1
            until docker compose exec -T db sh -lc 'pg_isready -h 127.0.0.1 -p 5432' >/dev/null 2>&1; do
              echo "  tentativa $i/$ATTEMPTS..."
              i=$((i+1))
              if [ $i -gt $ATTEMPTS ]; then
                echo "Postgres não respondeu a tempo."
                docker compose logs --no-color --tail=200 db || true
                exit 1
              fi
              sleep $SLEEP
            done
            echo "Postgres OK."

            echo "[5/6] Diagnóstico do ambiente do APP (tamanho do env)"
            SIZE=$(docker compose exec -T app /usr/bin/env | wc -c || echo 0)
            echo "ENV size (bytes): $SIZE"
            if [ "${SIZE:-0}" -gt 120000 ]; then
              echo "ERRO: Ambiente do container está grande demais (>120 KB). Dump de variáveis (top 30 por tamanho):"
              docker compose exec -T app /usr/bin/env | awk 'BEGIN{FS="="}{print length($0),$1}' | sort -nr | head -30
              exit 1
            fi

            echo "[6/6] Healthcheck do app (rota existente)"
            ATTEMPTS=30
            SLEEP=2
            i=1
            HEALTH_URL="${{ secrets.HEALTH_URL }}"
            [ -n "${HEALTH_URL}" ] || HEALTH_URL="http://127.0.0.1:8080/api/infra/health"
            until curl -fsS "$HEALTH_URL" >/dev/null; do
              echo "  tentativa $i/$ATTEMPTS..."
              i=$((i+1))
              if [ $i -gt $ATTEMPTS ]; then
                echo "App não respondeu no tempo esperado."
                echo "Logs do app:"
                docker compose logs --no-color --tail=200 app || true
                echo "Testando /openapi.json:"
                curl -v http://127.0.0.1:8080/openapi.json || true
                exit 1
              fi
              sleep $SLEEP
            done
            echo "App OK."

      - name: Done
        run: echo "Deploy finalizado com sucesso."
